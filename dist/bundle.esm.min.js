function e(e,t=!1,n){const r=e.match(/^(0x)?([\da-fA-F]+)$/);if(null==r)throw new RangeError("input must be a hexadecimal string, e.g. '0x124fe3a' or '0214f1b2'");let o=r[2];if(void 0!==n){if(n<o.length/2)throw new RangeError(`expected byte length ${n} < input hex byte length ${Math.ceil(o.length/2)}`);o=o.padStart(2*n,"0")}return t?"0x"+o:o}function t(e,t=!1){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return l(r(e),t)}function n(e){let t=8n;ArrayBuffer.isView(e)?t=BigInt(8*e.BYTES_PER_ELEMENT):e=new Uint8Array(e);let n=0n;for(const r of e.values()){n=(n<<t)+BigInt(r)}return n}function r(e,t=!1,n){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return e.toString(16)}function o(t){return BigInt(e(t,!0))}function a(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return u(l(e.toString(16)))}function i(e){return o(c(f(e)))}function u(e){return(new TextDecoder).decode(new Uint8Array(e))}function f(e,t=!1){return(new TextEncoder).encode(e).buffer}function c(t,n=!1,r){{let o="";const a="0123456789abcdef";return(t=ArrayBuffer.isView(t)?new Uint8Array(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)):new Uint8Array(t)).forEach((e=>{o+=a[e>>4]+a[15&e]})),e(o,n,r)}}function l(t,n=!1){let r=e(t);return r=e(t,!1,Math.ceil(r.length/2)),Uint8Array.from(r.match(/[\da-fA-F]{2}/g).map((e=>parseInt(e,16)))).buffer}function g(e,n=!1,r=!0){return function(e,t=!1,n=!0){let r="";return r=(e=>{const t=[];for(let n=0;n<e.length;n+=32768)t.push(String.fromCharCode.apply(null,e.subarray(n,n+32768)));return btoa(t.join(""))})("string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e)),t&&(r=function(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}(r)),n||(r=r.replace(/=/g,"")),r}(t(e),n,r)}function s(e){return n(function(e,t=!1){{let n=!1;if(/^[0-9a-zA-Z_-]+={0,2}$/.test(e))n=!0;else if(!/^[0-9a-zA-Z+/]*={0,2}$/.test(e))throw new Error("Not a valid base64 input");n&&(e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/=/g,""));const r=new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0))));return t?(new TextDecoder).decode(r):r}}(e))}export{s as base64ToBigint,g as bigintToBase64,t as bigintToBuf,r as bigintToHex,a as bigintToText,n as bufToBigint,c as bufToHex,u as bufToText,o as hexToBigint,l as hexToBuf,e as parseHex,i as textToBigint,f as textToBuf};
