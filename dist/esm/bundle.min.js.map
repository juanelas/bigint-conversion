{"version":3,"file":"bundle.min.js","sources":["../../node_modules/@juanelas/base64/dist/esm/index.browser.js","../../src/ts/index.ts"],"sourcesContent":["const base64Encode = (bytes) => {\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nconst base64Decode = (encoded) => {\n    return new Uint8Array(atob(encoded)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n};\n\nfunction encode(input, urlsafe = false, padding = true) {\n    let base64 = '';\n    {\n        const bytes = (typeof input === 'string')\n            ? (new TextEncoder()).encode(input)\n            : new Uint8Array(input);\n        base64 = base64Encode(bytes);\n    }\n    if (urlsafe)\n        base64 = base64ToBase64url(base64);\n    if (!padding)\n        base64 = removeBase64Padding(base64);\n    return base64;\n}\nfunction decode(base64, stringOutput = false) {\n    {\n        let urlsafe = false;\n        if (/^[0-9a-zA-Z_-]+={0,2}$/.test(base64)) {\n            urlsafe = true;\n        }\n        else if (!/^[0-9a-zA-Z+/]*={0,2}$/.test(base64)) {\n            throw new Error('Not a valid base64 input');\n        }\n        if (urlsafe)\n            base64 = base64urlToBase64(base64);\n        const bytes = base64Decode(base64);\n        return stringOutput\n            ? (new TextDecoder()).decode(bytes)\n            : bytes;\n    }\n}\nfunction base64ToBase64url(base64) {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction base64urlToBase64(base64url) {\n    return base64url.replace(/-/g, '+').replace(/_/g, '/').replace(/=/g, '');\n}\nfunction removeBase64Padding(str) {\n    return str.replace(/=/g, '');\n}\n\nexport { decode, encode };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYnJvd3Nlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RzL2Jyb3dzZXItYmFzZTY0LnRzIiwiLi4vLi4vc3JjL3RzL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBiYXNlNjRFbmNvZGUgPSAoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBDSFVOS19TSVpFID0gMHg4MDAwXG4gIGNvbnN0IGFyciA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IENIVU5LX1NJWkUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgYXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcy5zdWJhcnJheShpLCBpICsgQ0hVTktfU0laRSkpKVxuICB9XG4gIHJldHVybiBidG9hKGFyci5qb2luKCcnKSlcbn1cblxuZXhwb3J0IGNvbnN0IGJhc2U2NERlY29kZSA9IChlbmNvZGVkOiBzdHJpbmcpOiBVaW50OEFycmF5ID0+IHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFxuICAgIGF0b2IoZW5jb2RlZClcbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSlcbiAgKVxufVxuIiwiLyoqXG4gKiBCYXNlNjR1cmwgZm9yIGJvdGggbm9kZS5qcyBhbmQgYnJ3c2VyIGphdmFzY3JpcHQuIEl0IGNhbiB3b3JrIHdpdGggQXJyYXlCdWZmZXJ8VHlwZWRBcnJheXxCdWZmZXJcbiAqXG4gKiBAcmVtYXJrcyBCb3dzZXIgY29kZSBvYnRhaW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wYW52YS9qb3NlL2Jsb2IvbWFpbi9zcmMvcnVudGltZS9icm93c2VyL2Jhc2U2NHVybC50c1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0RW5jb2RlLCBiYXNlNjREZWNvZGUgfSBmcm9tICcuL2Jyb3dzZXItYmFzZTY0LmpzJ1xuXG4vKipcbiAqIEEgVHlwZWRBcnJheSBvYmplY3QgZGVzY3JpYmVzIGFuIGFycmF5LWxpa2UgdmlldyBvZiBhbiB1bmRlcmx5aW5nIGJpbmFyeSBkYXRhIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9IEludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheSB8IEJpZ0ludDY0QXJyYXkgfCBCaWdVaW50NjRBcnJheVxuXG4vKipcbiAqIEJhc2U2NFVybCBlbmNvZGluZyBvZiBhIGJ1ZmZlciBpbnB1dCBvciBhIHN0cmluZyAoVVRGMTYgaW4gYnJvd3NlcnMsIFVURjggaW4gbm9kZSlcbiAqIEBwYXJhbSBpbnB1dFxuICogQHBhcmFtIHVybHNhZmUgLSBpZiB0cnVlIEJhc2U2NCBVUkwgZW5jb2RpbmcgaXMgdXNlZCAoJysnIGFuZCAnLycgYXJlIHJlcGxhY2VkIGJ5ICctJywgJ18nKVxuICogQHBhcmFtIHBhZGRpbmcgLSBpZiBmYWxzZSwgcGFkZGluZyAodHJhaWxpbmcgJz0nKSBpcyByZW1vdmVkXG4gKiBAcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBiYXNlNjQtZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZSAoaW5wdXQ6IEFycmF5QnVmZmVyTGlrZSB8IFR5cGVkQXJyYXkgfCBCdWZmZXIgfCBzdHJpbmcsIHVybHNhZmU6IGJvb2xlYW4gPSBmYWxzZSwgcGFkZGluZzogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICBsZXQgYmFzZTY0ID0gJydcbiAgaWYgKElTX0JST1dTRVIpIHtcbiAgICBjb25zdCBieXRlcyA9ICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKVxuICAgICAgPyAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShpbnB1dClcbiAgICAgIDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpXG4gICAgYmFzZTY0ID0gYmFzZTY0RW5jb2RlKGJ5dGVzKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpXG4gICAgICA/IEJ1ZmZlci5mcm9tKGlucHV0LCAndXRmOCcpXG4gICAgICA6IEJ1ZmZlci5mcm9tKGlucHV0KVxuICAgIGJhc2U2NCA9IGJ5dGVzLnRvU3RyaW5nKCdiYXNlNjQnKVxuICB9XG4gIGlmICh1cmxzYWZlKSBiYXNlNjQgPSBiYXNlNjRUb0Jhc2U2NHVybChiYXNlNjQpXG4gIGlmICghcGFkZGluZykgYmFzZTY0ID0gcmVtb3ZlQmFzZTY0UGFkZGluZyhiYXNlNjQpXG4gIHJldHVybiBiYXNlNjRcbn1cblxuLyoqXG4gKiBCYXNlNjR1cmwgZGVjb2RpbmcgKGJpbmFyeSBvdXRwdXQpIG9mIGJhc2U2NHVybC1lbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIGJhc2U2NCAtIGEgYmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIHN0cmluZ091dHB1dCAtIGlmIHRydWUgYSBVVEYxNiAoYnJvd3Nlcikgb3IgVVRGOCAobm9kZSkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBAcmV0dXJucyBhIGJ1ZmZlciBvciB1bmljb2RlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlIChiYXNlNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUgKGJhc2U2NDogc3RyaW5nLCBzdHJpbmdPdXRwdXQ6IHVuZGVmaW5lZCk6IFVpbnQ4QXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUgKGJhc2U2NDogc3RyaW5nLCBzdHJpbmdPdXRwdXQ6IGZhbHNlKTogVWludDhBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSAoYmFzZTY0OiBzdHJpbmcsIHN0cmluZ091dHB1dDogdHJ1ZSk6IHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSAoYmFzZTY0OiBzdHJpbmcsIHN0cmluZ091dHB1dDogYm9vbGVhbik6IFVpbnQ4QXJyYXkgfCBzdHJpbmdcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUgKGJhc2U2NDogc3RyaW5nLCBzdHJpbmdPdXRwdXQ6IHVuZGVmaW5lZCB8IGJvb2xlYW4gPSBmYWxzZSk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcge1xuICBpZiAoSVNfQlJPV1NFUikge1xuICAgIGxldCB1cmxzYWZlID0gZmFsc2VcbiAgICBpZiAoL15bMC05YS16QS1aXy1dKz17MCwyfSQvLnRlc3QoYmFzZTY0KSkge1xuICAgICAgdXJsc2FmZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKCEvXlswLTlhLXpBLVorL10qPXswLDJ9JC8udGVzdChiYXNlNjQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGJhc2U2NCBpbnB1dCcpXG4gICAgfVxuICAgIGlmICh1cmxzYWZlKSBiYXNlNjQgPSBiYXNlNjR1cmxUb0Jhc2U2NChiYXNlNjQpXG4gICAgY29uc3QgYnl0ZXMgPSBiYXNlNjREZWNvZGUoYmFzZTY0KVxuICAgIHJldHVybiBzdHJpbmdPdXRwdXRcbiAgICAgID8gKG5ldyBUZXh0RGVjb2RlcigpKS5kZWNvZGUoYnl0ZXMpXG4gICAgICA6IGJ5dGVzXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0LCAnYmFzZTY0JylcbiAgICByZXR1cm4gc3RyaW5nT3V0cHV0XG4gICAgICA/IGJ1ZmZlci50b1N0cmluZygndXRmOCcpXG4gICAgICA6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIubGVuZ3RoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQmFzZTY0dXJsIChiYXNlNjQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJylcbn1cblxuZnVuY3Rpb24gYmFzZTY0dXJsVG9CYXNlNjQgKGJhc2U2NHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJhc2U2NHVybC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoLz0vZywgJycpXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJhc2U2NFBhZGRpbmcgKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC89L2csICcnKVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFPLE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBaUIsS0FBWTtJQUN4RCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUE7SUFDekIsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFBO0FBQ2QsSUFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksVUFBVSxFQUFFO1FBRWpELEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDN0UsS0FBQTtJQUNELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUMzQixDQUFDLENBQUE7QUFFTSxNQUFNLFlBQVksR0FBRyxDQUFDLE9BQWUsS0FBZ0I7QUFDMUQsSUFBQSxPQUFPLElBQUksVUFBVSxDQUNuQixJQUFJLENBQUMsT0FBTyxDQUFDO1NBQ1YsS0FBSyxDQUFDLEVBQUUsQ0FBQztBQUNULFNBQUEsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDL0IsQ0FBQTtBQUNILENBQUM7O0FDS0ssU0FBVSxNQUFNLENBQUUsS0FBcUQsRUFBRSxPQUFtQixHQUFBLEtBQUssRUFBRSxPQUFBLEdBQW1CLElBQUksRUFBQTtJQUM5SCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUE7QUFDZixJQUFnQjtBQUNkLFFBQUEsTUFBTSxLQUFLLEdBQUcsQ0FBQyxPQUFPLEtBQUssS0FBSyxRQUFRO2NBQ3BDLENBQUMsSUFBSSxXQUFXLEVBQUUsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ25DLGNBQUUsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDekIsUUFBQSxNQUFNLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQzdCLEtBS0E7QUFDRCxJQUFBLElBQUksT0FBTztBQUFFLFFBQUEsTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQy9DLElBQUEsSUFBSSxDQUFDLE9BQU87QUFBRSxRQUFBLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUNsRCxJQUFBLE9BQU8sTUFBTSxDQUFBO0FBQ2YsQ0FBQztTQWFlLE1BQU0sQ0FBRSxNQUFjLEVBQUUsZUFBb0MsS0FBSyxFQUFBO0FBQy9FLElBQWdCO1FBQ2QsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFBO0FBQ25CLFFBQUEsSUFBSSx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDekMsT0FBTyxHQUFHLElBQUksQ0FBQTtBQUNmLFNBQUE7QUFBTSxhQUFBLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDakQsWUFBQSxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUE7QUFDNUMsU0FBQTtBQUNELFFBQUEsSUFBSSxPQUFPO0FBQUUsWUFBQSxNQUFNLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDL0MsUUFBQSxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDbEMsUUFBQSxPQUFPLFlBQVk7Y0FDZixDQUFDLElBQUksV0FBVyxFQUFFLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQztjQUNqQyxLQUFLLENBQUE7QUFDVixLQUtBO0FBQ0gsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUUsTUFBYyxFQUFBO0FBQ3hDLElBQUEsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBQ3ZELENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUFFLFNBQWlCLEVBQUE7SUFDM0MsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFDMUUsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUUsR0FBVyxFQUFBO0lBQ3ZDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFDOUI7Ozs7In0=\n","/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\nimport * as b64 from '@juanelas/base64'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Parses a hexadecimal string for correctness and returns it with or without '0x' prefix, and/or with the specified byte length\n * @param a - the string with an hexadecimal number to be parsed\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n * @throws {@link RangeError} if requested byte length is less than the input byte length\n */\nexport function parseHex (a: string, prefix0x: boolean = false, byteLength?: number): string {\n  const hexMatch = a.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw new RangeError('input must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  if (byteLength !== undefined) {\n    if (byteLength < hex.length / 2) {\n      throw new RangeError(`expected byte length ${byteLength} < input hex byte length ${Math.ceil(hex.length / 2)}`)\n    }\n    hex = hex.padStart(byteLength * 2, '0')\n  }\n  return (prefix0x) ? '0x' + hex : hex\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer | TypedArray | Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf as TypedArray | Buffer).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0\n */\nexport function bigintToHex (a: bigint, prefix0x: boolean = false, byteLength?: number): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return parseHex(a.toString(16), prefix0x, byteLength)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt(parseHex(hexStr, true))\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer | TypedArray | Buffer): string {\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(buf))\n  else return Buffer.from(buf).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer | TypedArray | Buffer, prefix0x: boolean = false, byteLength?: number): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return parseHex(s, prefix0x, byteLength)\n  } else {\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    return parseHex(Buffer.from(buf).toString('hex'), prefix0x, byteLength)\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  let hex = parseHex(hexStr)\n  hex = parseHex(hexStr, false, Math.ceil(hex.length / 2)) // pad to have a length in bytes\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    return returnArrayBuffer ? b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength) : b\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a))\n}\n"],"names":["base64Encode","bytes","arr","i","length","push","String","fromCharCode","apply","subarray","btoa","join","base64Decode","encoded","Uint8Array","atob","split","map","c","charCodeAt","parseHex","a","prefix0x","byteLength","hexMatch","match","RangeError","hex","undefined","Math","ceil","padStart","bigintToBuf","returnArrayBuffer","hexToBuf","bigintToHex","bufToBigint","buf","bits","ArrayBuffer","isView","BigInt","BYTES_PER_ELEMENT","ret","values","toString","hexToBigint","hexStr","bigintToText","bufToText","textToBigint","text","bufToHex","textToBuf","TextDecoder","decode","str","TextEncoder","encode","buffer","s","h","slice","byteOffset","forEach","v","from","parseInt","bigintToBase64","urlsafe","padding","input","base64","replace","base64ToBase64url","b64.encode","base64ToBigint","stringOutput","test","Error","b64.decode"],"mappings":"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","x_google_ignoreList":[0]}