{"version":3,"file":"bundle.min.js","sources":["../../src/ts/index.ts","../../node_modules/@juanelas/base64/dist/esm/index.browser.js"],"sourcesContent":["/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\nimport * as b64 from '@juanelas/base64'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Parses a hexadecimal string for correctness and returns it with or without '0x' prefix, and/or with the specified byte length\n * @param a - the string with an hexadecimal number to be parsed\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n * @throws {@link RangeError} if requested byte length is less than the input byte length\n */\nexport function parseHex (a: string, prefix0x: boolean = false, byteLength?: number): string {\n  const hexMatch = a.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw new RangeError('input must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  if (byteLength !== undefined) {\n    if (byteLength < hex.length / 2) {\n      throw new RangeError(`expected byte length ${byteLength} < input hex byte length ${Math.ceil(hex.length / 2)}`)\n    }\n    hex = hex.padStart(byteLength * 2, '0')\n  }\n  return (prefix0x) ? '0x' + hex : hex\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer | TypedArray | Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf as TypedArray | Buffer).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0\n */\nexport function bigintToHex (a: bigint, prefix0x: boolean = false, byteLength?: number): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return parseHex(a.toString(16), prefix0x, byteLength)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt(parseHex(hexStr, true))\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer | TypedArray | Buffer): string {\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(buf))\n  else return Buffer.from(buf).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer | TypedArray | Buffer, prefix0x: boolean = false, byteLength?: number): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return parseHex(s, prefix0x, byteLength)\n  } else {\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    return parseHex(Buffer.from(buf).toString('hex'), prefix0x, byteLength)\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  let hex = parseHex(hexStr)\n  hex = parseHex(hexStr, false, Math.ceil(hex.length / 2)) // pad to have a length in bytes\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    return returnArrayBuffer ? b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength) : b\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a))\n}\n","function e(e,r=!1,t=!0){let n=\"\";n=(e=>{const r=[];for(let t=0;t<e.length;t+=32768)r.push(String.fromCharCode.apply(null,e.subarray(t,t+32768)));return btoa(r.join(\"\"))})(\"string\"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e));return r&&(n=function(e){return e.replace(/\\+/g,\"-\").replace(/\\//g,\"_\")}(n)),t||(n=n.replace(/=/g,\"\")),n}function r(e,r=!1){{let t=!1;if(/^[0-9a-zA-Z_-]+={0,2}$/.test(e))t=!0;else if(!/^[0-9a-zA-Z+/]*={0,2}$/.test(e))throw new Error(\"Not a valid base64 input\");t&&(e=e.replace(/-/g,\"+\").replace(/_/g,\"/\").replace(/=/g,\"\"));const n=new Uint8Array(atob(e).split(\"\").map((e=>e.charCodeAt(0))));return r?(new TextDecoder).decode(n):n}}export{r as decode,e as encode};\n//# sourceMappingURL=index.browser.js.map\n"],"names":["parseHex","a","prefix0x","byteLength","hexMatch","match","RangeError","hex","undefined","length","Math","ceil","padStart","bigintToBuf","returnArrayBuffer","hexToBuf","bigintToHex","bufToBigint","buf","bits","ArrayBuffer","isView","BigInt","BYTES_PER_ELEMENT","Uint8Array","ret","i","values","toString","hexToBigint","hexStr","bigintToText","bufToText","textToBigint","text","bufToHex","textToBuf","TextDecoder","decode","str","TextEncoder","encode","buffer","s","h","slice","byteOffset","forEach","v","from","map","parseInt","bigintToBase64","urlsafe","padding","e","r","t","n","push","String","fromCharCode","apply","subarray","btoa","join","replace","b64.encode","base64ToBigint","test","Error","atob","split","charCodeAt","b64.decode"],"mappings":"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","x_google_ignoreList":[1]}