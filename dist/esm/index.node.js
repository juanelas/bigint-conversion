import*as e from"@juanelas/base64";function t(e,t=!1,n){const r=e.match(/^(0x)?([\da-fA-F]+)$/);if(null==r)throw new RangeError("input must be a hexadecimal string, e.g. '0x124fe3a' or '0214f1b2'");let o=r[2];if(void 0!==n){if(n<o.length/2)throw new RangeError(`expected byte length ${n} < input hex byte length ${Math.ceil(o.length/2)}`);o=o.padStart(2*n,"0")}return t?"0x"+o:o}function n(e,t=!1){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return s(o(e),t)}function r(e){let t=8n;ArrayBuffer.isView(e)?t=BigInt(8*e.BYTES_PER_ELEMENT):e=new Uint8Array(e);let n=0n;for(const r of e.values()){n=(n<<t)+BigInt(r)}return n}function o(e,n=!1,r){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return t(e.toString(16),n,r)}function f(e){return BigInt(t(e,!0))}function i(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return a(s(e.toString(16)))}function u(e){return f(c(g(e)))}function a(e){return Buffer.from(e).toString()}function g(e,t=!1){return t?(new TextEncoder).encode(e).buffer:Buffer.from((new TextEncoder).encode(e).buffer)}function c(e,n=!1,r){return ArrayBuffer.isView(e)&&(e=new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength))),t(Buffer.from(e).toString("hex"),n,r)}function s(e,n=!1){let r=t(e);r=t(e,!1,Math.ceil(r.length/2));{const e=Buffer.from(r,"hex");return n?e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength):e}}function l(t,r=!1,o=!0){return e.encode(n(t),r,o)}function h(t){return r(e.decode(t))}export{h as base64ToBigint,l as bigintToBase64,n as bigintToBuf,o as bigintToHex,i as bigintToText,r as bufToBigint,c as bufToHex,a as bufToText,f as hexToBigint,s as hexToBuf,t as parseHex,u as textToBigint,g as textToBuf};
//# sourceMappingURL=index.node.js.map
