!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).bigintConversion={})}(this,(function(e){"use strict";function n(e){return e<26?e+65:e<52?e+71:e<62?e-4:62===e?43:63===e?47:65}function t(e,t=!1,r=!0){let o="";o=function(e){let t=2,r="";for(var o=e.length,i=0,f=0;f<o;f++)t=f%3,f>0&&4*f/3%76==0&&(r+="\r\n"),i|=e[f]<<(16>>>t&24),2!==t&&e.length-f!=1||(r+=String.fromCharCode(n(i>>>18&63),n(i>>>12&63),n(i>>>6&63),n(63&i)),i=0);return r.substr(0,r.length-2+t)+(2===t?"":1===t?"=":"==")}("string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e));return t&&(o=function(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}(o)),r||(o=o.replace(/=/g,"")),o}function r(e,n=!1){{let t=!1;if(/^[0-9a-zA-Z_-]+={0,2}$/.test(e))t=!0;else if(!/^[0-9a-zA-Z+/]*={0,2}$/.test(e))throw new Error("Not a valid base64 input");t&&(e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/=/g,""));const r=function(e){const n=e.length,t=3*n+1>>2,r=new Uint8Array(t);for(var o,i,f=0,u=0,a=0;a<n;a++)if(i=3&a,f|=((c=e.charCodeAt(a))>64&&c<91?c-65:c>96&&c<123?c-71:c>47&&c<58?c+4:43===c?62:47===c?63:0)<<6*(3-i),3===i||n-a==1){for(o=0;o<3&&u<t;o++,u++)r[u]=f>>>(16>>>o&24)&255;f=0}var c;return r}(e);return n?(new TextDecoder).decode(r):r}}function o(e,n=!1){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return s(f(e),n)}function i(e){let n=8n;ArrayBuffer.isView(e)?n=BigInt(8*e.BYTES_PER_ELEMENT):e=new Uint8Array(e);let t=0n;for(const r of e.values()){t=(t<<n)+BigInt(r)}return t}function f(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return e.toString(16)}function u(e){return BigInt("0x"+e)}function a(e){return(new TextDecoder).decode(new Uint8Array(e))}function c(e,n=!1){return(new TextEncoder).encode(e).buffer}function g(e){{let n="";const t="0123456789abcdef";return(e=ArrayBuffer.isView(e)?new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)):new Uint8Array(e)).forEach((e=>{n+=t[e>>4]+t[15&e]})),n}}function s(e,n=!1){if(void 0===e)throw RangeError("hexStr cannot undefined");const t=e.match(/^(0x)?([\da-fA-F]+)$/);if(null==t)throw RangeError("hexStr must be a hexadecimal string, e.g. '0x124fe3a' or '0214f1b2'");let r=t[2];return r=r.length%2==0?r:"0"+r,Uint8Array.from(r.match(/[\da-fA-F]{2}/g).map((e=>parseInt(e,16)))).buffer}e.base64ToBigint=function(e){return i(r(e))},e.bigintToBase64=function(e,n=!1,r=!0){return t(o(e),n,r)},e.bigintToBuf=o,e.bigintToHex=f,e.bigintToText=function(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return a(s(e.toString(16)))},e.bufToBigint=i,e.bufToHex=g,e.bufToText=a,e.hexToBigint=u,e.hexToBuf=s,e.textToBigint=function(e){return u(g(c(e)))},e.textToBuf=c,Object.defineProperty(e,"__esModule",{value:!0})}));
