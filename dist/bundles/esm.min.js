function e(e,t=!1,n=!0){let r="";r=(e=>{const t=[];for(let n=0;n<e.length;n+=32768)t.push(String.fromCharCode.apply(null,e.subarray(n,n+32768)));return btoa(t.join(""))})("string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e));return t&&(r=function(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}(r)),n||(r=r.replace(/=/g,"")),r}function t(e,t=!1){{let n=!1;if(/^[0-9a-zA-Z_-]+={0,2}$/.test(e))n=!0;else if(!/^[0-9a-zA-Z+/]*={0,2}$/.test(e))throw new Error("Not a valid base64 input");n&&(e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/=/g,""));const r=new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0))));return t?(new TextDecoder).decode(r):r}}function n(e,t=!1,n){const r=e.match(/^(0x)?([\da-fA-F]+)$/);if(null==r)throw new RangeError("input must be a hexadecimal string, e.g. '0x124fe3a' or '0214f1b2'");let o=r[2];if(void 0!==n){if(n<o.length/2)throw new RangeError(`expected byte length ${n} < input hex byte length ${Math.ceil(o.length/2)}`);o=o.padStart(2*n,"0")}return t?"0x"+o:o}function r(e,t=!1){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return s(a(e),t)}function o(e){let t=8n;ArrayBuffer.isView(e)?t=BigInt(8*e.BYTES_PER_ELEMENT):e=new Uint8Array(e);let n=0n;for(const r of e.values()){n=(n<<t)+BigInt(r)}return n}function a(e,t=!1,n){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return e.toString(16)}function i(e){return BigInt(n(e,!0))}function u(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return c(s(e.toString(16)))}function f(e){return i(g(l(e)))}function c(e){return(new TextDecoder).decode(new Uint8Array(e))}function l(e,t=!1){return(new TextEncoder).encode(e).buffer}function g(e,t=!1,r){{let o="";const a="0123456789abcdef";return(e=ArrayBuffer.isView(e)?new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)):new Uint8Array(e)).forEach((e=>{o+=a[e>>4]+a[15&e]})),n(o,t,r)}}function s(e,t=!1){let r=n(e);return r=n(e,!1,Math.ceil(r.length/2)),Uint8Array.from(r.match(/[\da-fA-F]{2}/g).map((e=>parseInt(e,16)))).buffer}function d(t,n=!1,o=!0){return e(r(t),n,o)}function h(e){return o(t(e))}export{h as base64ToBigint,d as bigintToBase64,r as bigintToBuf,a as bigintToHex,u as bigintToText,o as bufToBigint,g as bufToHex,c as bufToText,i as hexToBigint,s as hexToBuf,n as parseHex,f as textToBigint,l as textToBuf};
