function e(e,n=!1){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return c(r(e),n)}function n(e){let n=8n;ArrayBuffer.isView(e)?n=BigInt(8*e.BYTES_PER_ELEMENT):e=new Uint8Array(e);let r=0n;for(const t of e.values()){r=(r<<n)+BigInt(t)}return r}function r(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return e.toString(16)}function t(e){return BigInt("0x"+e)}function o(e){if(e<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return a(c(e.toString(16)))}function i(e){return t(f(u(e)))}function a(e){return(new TextDecoder).decode(new Uint8Array(e))}function u(e,n=!1){return(new TextEncoder).encode(e).buffer}function f(e){{let n="";const r="0123456789abcdef";return(e=ArrayBuffer.isView(e)?new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)):new Uint8Array(e)).forEach((e=>{n+=r[e>>4]+r[15&e]})),n}}function c(e,n=!1){return e=e.length%2?"0"+e:e,Uint8Array.from(e.trimLeft("0x").match(/[\da-f]{2}/gi).map((e=>parseInt(e,16)))).buffer}export{e as bigintToBuf,r as bigintToHex,o as bigintToText,n as bufToBigint,f as bufToHex,a as bufToText,t as hexToBigint,c as hexToBuf,i as textToBigint,u as textToBuf};
